import DataLoader from 'dataloader'
import { getConnection } from 'typeorm'
import { Users } from '../entities/user'

export const DirectMessageLoader = () =>
  new DataLoader<{ userId: number; teamId: number }, Users[] | null>(
    //@ts-ignore
    async (keys) => {
      const teamIds = keys.map((t) => t.teamId)
      const users = await getConnection() // "" use double quotes for AS syntax
        .query(
          `
    select 
    distinct on (u.id,dm.team_id)
    u.id, u.username, dm.team_id "teamId"
    from users u
    inner join public.direct_message dm on (u.id= dm.sender_id) or (u.id= dm.receiver_id)
    where ($1 = dm.sender_id or $1 = dm.receiver_id) and dm.team_id = any($2);
    `,
          [keys[0].userId, teamIds]
        )
      //    distinct on (u.id,dm.team_id): unique rows
      const userObject: Record<string, Users[]> = {}
      users.forEach((u: any) => {
        if (userObject[u.teamId]) {
          // if property exist push
          userObject[u.teamId].push(u)
        } else {
          // else make a array with object
          userObject[u.teamId] = [u]
        }
      })
      return keys.map((u) => {
        let newObject
        if (userObject[u.teamId]) {
          newObject = userObject[u.teamId].filter(
            (u) => u.id !== keys[0].userId
          )
        }
        return newObject
      })
    }
  )

/* inner join is not left join  

select 
    distinct on (u.id,dm.team_id)
    u.id, u.username, dm.team_id
    from users u
    inner join public.direct_message dm on (u.id= dm.sender_id) or (u.id= dm.receiver_id)

    this selects every user who has sent or recieved message. 

    no of record generated by above sql === no of record directMessage

    every record in directMessage has a user. so, there could be duplicates with user being receiver and sender. 
    */
